/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package dev.androidbroadcast.framesdk.apis

import dev.androidbroadcast.framesdk.models.Comment
import dev.androidbroadcast.framesdk.models.CommentImpression
import dev.androidbroadcast.framesdk.models.CreateCommentRequest
import dev.androidbroadcast.framesdk.models.HTTPError

import dev.androidbroadcast.framesdk.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class CommentsApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Mark completed
     * Complete a \&quot;Task\&quot; on a given Comment
     * @param commentId Comment ID
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun completeComment(commentId: kotlin.String): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/comments/{comment_id}/complete".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create a Comment
     * Leave a Comment on an Asset
     * @param assetId 
     * @param createCommentRequest Comment to create or update (optional)
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createComment(assetId: kotlin.String, createCommentRequest: CreateCommentRequest? = null): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = createCommentRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets/{asset_id}/comments".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a Like on a Comment
     * Leave a thumbs-up on a Comment
     * @param commentId 
     * @return kotlin.collections.List<CommentImpression>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createCommentImpressionLike(commentId: kotlin.String): HttpResponse<kotlin.collections.List<CommentImpression>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/comments/{comment_id}/like".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<CreateCommentImpressionLikeResponse>().map { value }
    }

    @Serializable(CreateCommentImpressionLikeResponse.Companion::class)
    private class CreateCommentImpressionLikeResponse(val value: List<CommentImpression>) {
        companion object : KSerializer<CreateCommentImpressionLikeResponse> {
            private val serializer: KSerializer<List<CommentImpression>> = serializer<List<CommentImpression>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: CreateCommentImpressionLikeResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = CreateCommentImpressionLikeResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Leave a Reply on a Comment
     * Leave a Reply on a given Comment
     * @param commentId Comment ID
     * @param createCommentRequest Comment to create or update (optional)
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createReply(commentId: kotlin.String, createCommentRequest: CreateCommentRequest? = null): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = createCommentRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/comments/{comment_id}/replies".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete a Comment
     * Delete a Comment or Reply using its ID
     * @param commentId Comment ID
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteComment(commentId: kotlin.String): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/comments/{comment_id}".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete a like from a comment
     * Remove a Like from a Comment
     * @param commentId 
     * @return kotlin.collections.List<CommentImpression>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteCommentImpressionLike(commentId: kotlin.String): HttpResponse<kotlin.collections.List<CommentImpression>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/comments/{comment_id}/like".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<DeleteCommentImpressionLikeResponse>().map { value }
    }

    @Serializable(DeleteCommentImpressionLikeResponse.Companion::class)
    private class DeleteCommentImpressionLikeResponse(val value: List<CommentImpression>) {
        companion object : KSerializer<DeleteCommentImpressionLikeResponse> {
            private val serializer: KSerializer<List<CommentImpression>> = serializer<List<CommentImpression>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: DeleteCommentImpressionLikeResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = DeleteCommentImpressionLikeResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get a Comment by ID
     * Fetch a Comment by its ID
     * @param commentId Comment ID
     * @param include  (optional)
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getComment(commentId: kotlin.String, include: kotlin.String? = null): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        include?.apply { localVariableQuery["include"] = listOf("$include") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/comments/{comment_id}".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get impressions
     * Fetch a list of who has &#39;seen&#39; your comment
     * @param commentId 
     * @param include  (optional)
     * @return kotlin.collections.List<CommentImpression>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getCommentImpressions(commentId: kotlin.String, include: kotlin.String? = null): HttpResponse<kotlin.collections.List<CommentImpression>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        include?.apply { localVariableQuery["include"] = listOf("$include") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/comments/{comment_id}/impressions".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetCommentImpressionsResponse>().map { value }
    }

    @Serializable(GetCommentImpressionsResponse.Companion::class)
    private class GetCommentImpressionsResponse(val value: List<CommentImpression>) {
        companion object : KSerializer<GetCommentImpressionsResponse> {
            private val serializer: KSerializer<List<CommentImpression>> = serializer<List<CommentImpression>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetCommentImpressionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetCommentImpressionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get all the Comments and Replies from  a Comment thread
     * This endpoint will return all comments and replies in a flat list.
     * @param assetId 
     * @param include  (optional)
     * @return kotlin.collections.List<Comment>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getComments(assetId: kotlin.String, include: kotlin.String? = null): HttpResponse<kotlin.collections.List<Comment>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        include?.apply { localVariableQuery["include"] = listOf("$include") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/assets/{asset_id}/comments".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetCommentsResponse>().map { value }
    }

    @Serializable(GetCommentsResponse.Companion::class)
    private class GetCommentsResponse(val value: List<Comment>) {
        companion object : KSerializer<GetCommentsResponse> {
            private val serializer: KSerializer<List<Comment>> = serializer<List<Comment>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetCommentsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetCommentsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get comments and replies
     * Fetch all Comments and Replies for a given Comment or Reply ID
     * @param commentId Comment ID
     * @param include  (optional, default to "replies")
     * @return kotlin.collections.List<Comment>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getReplies(commentId: kotlin.String, include: kotlin.String? = "replies"): HttpResponse<kotlin.collections.List<Comment>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        include?.apply { localVariableQuery["include"] = listOf("$include") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/comments/{comment_id}/replies".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetRepliesResponse>().map { value }
    }

    @Serializable(GetRepliesResponse.Companion::class)
    private class GetRepliesResponse(val value: List<Comment>) {
        companion object : KSerializer<GetRepliesResponse> {
            private val serializer: KSerializer<List<Comment>> = serializer<List<Comment>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetRepliesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetRepliesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Mark a Comment as Uncompleted
     * If a Comment has been marked **Completed**, you can reset its to **Uncompleted** by hitting this endpoint.
     * @param commentId Comment ID
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun uncompleteComment(commentId: kotlin.String): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/comments/{comment_id}/complete".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update a Comment
     * Update a Comment via its ID, overwriting only the passed key/value pairs
     * @param commentId Comment ID
     * @param createCommentRequest Comment to create or update (optional)
     * @return Comment
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateComment(commentId: kotlin.String, createCommentRequest: CreateCommentRequest? = null): HttpResponse<Comment> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = createCommentRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v2/comments/{comment_id}".replace("{" + "comment_id" + "}", "$commentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
