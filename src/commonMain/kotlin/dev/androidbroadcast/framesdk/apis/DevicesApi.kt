/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package dev.androidbroadcast.framesdk.apis

import dev.androidbroadcast.framesdk.models.AuthDeviceConfirmDevice200Response
import dev.androidbroadcast.framesdk.models.AuthDeviceConfirmDevice400Response
import dev.androidbroadcast.framesdk.models.ConnectDeviceChannelRequest
import dev.androidbroadcast.framesdk.models.CreateAsset200Response
import dev.androidbroadcast.framesdk.models.CreateRealtimeUploadParts200Response
import dev.androidbroadcast.framesdk.models.CreateRealtimeUploadPartsRequest
import dev.androidbroadcast.framesdk.models.DeviceAssetCreateDeprecated409Response
import dev.androidbroadcast.framesdk.models.DeviceAssetCreateDeprecatedRequest
import dev.androidbroadcast.framesdk.models.DeviceAssetCreateDeprecatedRequest1
import dev.androidbroadcast.framesdk.models.DeviceListAccounts200ResponseInner
import dev.androidbroadcast.framesdk.models.DeviceListProjects200ResponseInner
import dev.androidbroadcast.framesdk.models.DeviceRequestCode200Response
import dev.androidbroadcast.framesdk.models.HTTPError
import dev.androidbroadcast.framesdk.models.ProjectDevice
import dev.androidbroadcast.framesdk.models.ProjectDeviceAuthorization
import dev.androidbroadcast.framesdk.models.ProjectDeviceChannel
import dev.androidbroadcast.framesdk.models.TriggerRealtimeLoggingEventRequest
import dev.androidbroadcast.framesdk.models.User

import dev.androidbroadcast.framesdk.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class DevicesApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)


    /**
     * enum for parameter grantType
     */
    @Serializable
    enum class GrantTypeAuthDeviceConfirmDevice(val value: kotlin.String) {
        
        @SerialName(value = "urn:ietf:params:oauth:grant-type:device_code")
        urnColonIetfColonParamsColonOauthColonGrantMinusTypeColonDevice_code("urn:ietf:params:oauth:grant-type:device_code")
        
    }

    /**
     * Polling for Device Authorization
     * Once we have handed the pairing code to the user, we need to check and see if they&#39;ve entered it. To do so, we can make the following request.
     * @param grantType The type of authorization grant our OAuth system is issuing.
     * @param clientId The unique device id, such as the device serial number. Must be the same as the client id used on the initiation request.
     * @param deviceCode The unique &#x60;device_code&#x60; generated by the server for this authorization attempt. Returned from the initiation request.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return AuthDeviceConfirmDevice200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun authDeviceConfirmDevice(grantType: GrantTypeAuthDeviceConfirmDevice, clientId: kotlin.String, deviceCode: kotlin.String, xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<AuthDeviceConfirmDevice200Response> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            formData {
                grantType?.apply { append("grant_type", grantType) }
                clientId?.apply { append("client_id", clientId) }
                deviceCode?.apply { append("device_code", deviceCode) }
            }

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/auth/token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return multipartFormRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter grantType
     */
    @Serializable
    enum class GrantTypeAuthDeviceRefreshToken(val value: kotlin.String) {
        
        @SerialName(value = "refresh_token")
        refresh_token("refresh_token")
        
    }

    /**
     * Refresh Device Token
     * Refresh your devices token
     * @param clientId Must be a unique identifier per hardware device, such as a unique hardware serial number. Must be the same as the client id used on initial authorization.
     * @param clientSecret A static string, provided by Frame.io to be embedded for a device manufacturer/model. Acts as an identifier within Frame.io.
     * @param grantType Grant type
     * @param refreshTokem A valid &#x60;refresh_token&#x60;, from a previous authorization. Refresh tokens are valid for 14 days from issuance. This is received after the initial authorization and will receive a new &#x60;refresh-token&#x60; after every refresh.
     * @return void
     */
    open suspend fun authDeviceRefreshToken(clientId: kotlin.String, clientSecret: kotlin.String, grantType: GrantTypeAuthDeviceRefreshToken, refreshTokem: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            formData {
                clientId?.apply { append("client_id", clientId) }
                clientSecret?.apply { append("client_secret", clientSecret) }
                grantType?.apply { append("grant_type", grantType) }
                refreshTokem?.apply { append("refresh_tokem", refreshTokem) }
            }

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/auth/token",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return multipartFormRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Revoke Device Authorization
     * Revoke device authorization
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param clientId Must be a unique identifier per hardware device, such as a unique hardware serial number. Must be the same &#x60;client_id&#x60; used on initial authorization. (optional)
     * @param clientSecret A static string, provided by Frame.io to be embedded for a device manufacturer/model. Acts as an identifier within Frame.io. (optional)
     * @param token  (optional)
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun authDeviceRevokeToken(xClientVersion: kotlin.String? = "0.0.0", clientId: kotlin.String? = null, clientSecret: kotlin.String? = null, token: kotlin.String? = null): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            formData {
                clientId?.apply { append("client_id", clientId) }
                clientSecret?.apply { append("client_secret", clientSecret) }
                token?.apply { append("token", token) }
            }

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/auth/revoke",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return multipartFormRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Connect a new device channel
     * We can connect a new channel with the following request
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param connectDeviceChannelRequest Payload (optional)
     * @return ProjectDeviceChannel
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun connectDeviceChannel(xClientVersion: kotlin.String? = "0.0.0", connectDeviceChannelRequest: ConnectDeviceChannelRequest? = null): HttpResponse<ProjectDeviceChannel> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = connectDeviceChannelRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/channels",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create C2C asset
     * Asset upload initiation specifically for C2C devices and applications.  Note: This endpoint used to be &#x60;/v2/assets&#x60;, and while that endpoint will continue to function as normal, we suggest you use this one instead.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param deviceAssetCreateDeprecatedRequest While supported, we encourage you to switch from &#x60;application/x-ww-form-urlencoded&#x60; to &#x60;application/json&#x60; in order to support future workflows that will only be supported through JSON.  When &#x60;is_realtime_upload&#x60; is &#x60;true&#x60;, call must be made in &#x60;application/json&#x60;. (optional)
     * @return CreateAsset200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceAssetCreate(xClientVersion: kotlin.String? = "0.0.0", deviceAssetCreateDeprecatedRequest: DeviceAssetCreateDeprecatedRequest? = null): HttpResponse<CreateAsset200Response> {

        val localVariableAuthNames = listOf<String>("C2COAuth2", "C2CDeviceAuth")

        val localVariableBody = deviceAssetCreateDeprecatedRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create C2C asset
     * **THIS ENDPOINT IS DEPRECATED**. Please use &#x60;/v2/devices/assets&#x60; instead. While this endpoint will continue to function as normal, we ask that integrations begin using the new endpoint instead for consistency with the rest of the C2C API.  Asset upload initiation specifically for C2C devices and applications.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param deviceAssetCreateDeprecatedRequest While supported, we encourage you to switch from &#x60;application/x-ww-form-urlencoded&#x60; to &#x60;application/json&#x60; in order to support future workflows that will only be supported through JSON.  When &#x60;is_realtime_upload&#x60; is &#x60;true&#x60;, call must be made in &#x60;application/json&#x60;. (optional)
     * @return CreateAsset200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceAssetCreateDeprecated(xClientVersion: kotlin.String? = "0.0.0", deviceAssetCreateDeprecatedRequest: DeviceAssetCreateDeprecatedRequest? = null): HttpResponse<CreateAsset200Response> {

        val localVariableAuthNames = listOf<String>("C2COAuth2", "C2CDeviceAuth")

        val localVariableBody = deviceAssetCreateDeprecatedRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Request upload URLs for real-time upload
     * Register real-time upload parts and generate presigned AWS S3 upload PUT URLs.
     * @param assetId Asset ID
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param createRealtimeUploadPartsRequest Enumerates parts that upload URLs should be created for. (optional)
     * @return CreateRealtimeUploadParts200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceCreateRealtimeUploadParts(assetId: kotlin.String, xClientVersion: kotlin.String? = "0.0.0", createRealtimeUploadPartsRequest: CreateRealtimeUploadPartsRequest? = null): HttpResponse<CreateRealtimeUploadParts200Response> {

        val localVariableAuthNames = listOf<String>("C2COAuth2", "C2CDeviceAuth")

        val localVariableBody = createRealtimeUploadPartsRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/assets/{asset_id}/realtime_upload/parts".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Heartbeat ping
     * Ommit heartbeat event to Frame.io. This powers the device \&quot;online\&quot; status in the C2C Connections tab on iOS and Web.  This should be called no more then once a minute, and no less than once every 5 minutes.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return void
     */
    open suspend fun deviceHeartbeat(xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/heartbeat",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Device Information
     * Fetches information about the current device connection.   Can be used to verify authorization token and returns information useful to present useful information in your user interface.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return ProjectDeviceAuthorization
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceIdentify(xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<ProjectDeviceAuthorization> {

        val localVariableAuthNames = listOf<String>("C2CDeviceAuth", "OAuth2", "OAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/devices/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List accounts
     * List available accounts to pair your C2C device with.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return kotlin.collections.Set<DeviceListAccounts200ResponseInner>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceListAccounts(xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<kotlin.collections.Set<DeviceListAccounts200ResponseInner>> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/devices/accounts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<DeviceListAccountsResponse>().map { value }
    }

    @Serializable(DeviceListAccountsResponse.Companion::class)
    private class DeviceListAccountsResponse(val value: List<DeviceListAccounts200ResponseInner>) {
        companion object : KSerializer<DeviceListAccountsResponse> {
            private val serializer: KSerializer<List<DeviceListAccounts200ResponseInner>> = serializer<List<DeviceListAccounts200ResponseInner>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: DeviceListAccountsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = DeviceListAccountsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * List projects for account
     * List available Projects to pair your C2C device with.
     * @param accountId Account ID
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return kotlin.collections.Set<DeviceListProjects200ResponseInner>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceListProjects(accountId: kotlin.String, xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<kotlin.collections.Set<DeviceListProjects200ResponseInner>> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/devices/accounts/{account_id}/projects".replace("{" + "account_id" + "}", "$accountId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<DeviceListProjectsResponse>().map { value }
    }

    @Serializable(DeviceListProjectsResponse.Companion::class)
    private class DeviceListProjectsResponse(val value: List<DeviceListProjects200ResponseInner>) {
        companion object : KSerializer<DeviceListProjectsResponse> {
            private val serializer: KSerializer<List<DeviceListProjects200ResponseInner>> = serializer<List<DeviceListProjects200ResponseInner>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: DeviceListProjectsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = DeviceListProjectsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Connect device
     * Connect to the provided C2C Project.
     * @param projectId The &#x60;project_id&#x60; you intend to connect to (optional)
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return ProjectDevice
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceProjectConnect(projectId: kotlin.String? = null, xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<ProjectDevice> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        projectId?.apply { localVariableQuery["project_id"] = listOf("$projectId") }
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/connect",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Disconnect device
     * Disconnect the device from the project it&#39;s currently connected to.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return void
     */
    open suspend fun deviceProjectDisconnect(xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/disconnect",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter scope
     */
    @Serializable
    enum class ScopeDeviceRequestCode(val value: kotlin.String) {
        
        @SerialName(value = "asset_create")
        asset_create("asset_create"),
        
        @SerialName(value = "offline")
        offline("offline")
        
    }

    /**
     * Request device code
     * 
     * @param clientId A unique identifier for the physical hardware device. This value needs to be guaranteed to be unique for the device. This could be a serial number or a randomly generated UUID.
     * @param clientSecret This will be issued to you by Frame.io support and identifies the your device model. This value should be kept secret from the user, and should be encrypted at rest
     * @param scope The permissions we are requesting, with spaces used as delimiters. Hardware devices can only request the following two scopes
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return DeviceRequestCode200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceRequestCode(clientId: kotlin.String, clientSecret: kotlin.String, scope: ScopeDeviceRequestCode, xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<DeviceRequestCode200Response> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            formData {
                clientId?.apply { append("client_id", clientId) }
                clientSecret?.apply { append("client_secret", clientSecret) }
                scope?.apply { append("scope", scope) }
            }

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/device/code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return multipartFormRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Disconnect all device channels
     * Disconnects all connected device channels
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return void
     */
    open suspend fun disconnectAllDeviceChannels(xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/channels/disconnect",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Disconnect a specific device channel
     * Disconnect a device channel with the following request
     * @param channelId Device channel id
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @return void
     */
    open suspend fun disconnectDeviceChannel(channelId: kotlin.String, xClientVersion: kotlin.String? = "0.0.0"): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/channels/{channel_id}/disconnect".replace("{" + "channel_id" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get the current authenticated User
     * Get information about the currently authenticated user
     * @return User
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMe(): HttpResponse<User> {

        val localVariableAuthNames = listOf<String>("C2COAuth2", "OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Trigger a real-time logging event
     * Triggers an event on the device channel.    Can be used for logging a quick comment, or for other things that haven&#39;t been dreamed up yet!
     * @param channelId Device channel id
     * @param inputIndex An 0-indexed integer that will be used to identify the input
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param triggerRealtimeLoggingEventRequest  (optional)
     * @return void
     */
    open suspend fun triggerRealtimeLoggingEvent(channelId: kotlin.String, inputIndex: kotlin.Int, xClientVersion: kotlin.String? = "0.0.0", triggerRealtimeLoggingEventRequest: TriggerRealtimeLoggingEventRequest? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("C2COAuth2")

        val localVariableBody = triggerRealtimeLoggingEventRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/channels/{channel_id}/inputs/{input_index}/trigger".replace("{" + "channel_id" + "}", "$channelId").replace("{" + "input_index" + "}", "$inputIndex"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
