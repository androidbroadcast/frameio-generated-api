/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package dev.androidbroadcast.framesdk.apis

import dev.androidbroadcast.framesdk.models.AddVersionToAssetRequest
import dev.androidbroadcast.framesdk.models.Asset
import dev.androidbroadcast.framesdk.models.AssetAudio
import dev.androidbroadcast.framesdk.models.AssetSearch
import dev.androidbroadcast.framesdk.models.AssetSearchGetTeamIdParameter
import dev.androidbroadcast.framesdk.models.AssetSubtitle
import dev.androidbroadcast.framesdk.models.BatchCopyAsset200Response
import dev.androidbroadcast.framesdk.models.BatchCopyAssetRequest
import dev.androidbroadcast.framesdk.models.BatchCreateCollaborators200Response
import dev.androidbroadcast.framesdk.models.BatchDeleteAssetRequest
import dev.androidbroadcast.framesdk.models.CopyAssetRequest
import dev.androidbroadcast.framesdk.models.CreateAsset200Response
import dev.androidbroadcast.framesdk.models.CreateAssetRequest
import dev.androidbroadcast.framesdk.models.CreateRealtimeUploadParts200Response
import dev.androidbroadcast.framesdk.models.CreateRealtimeUploadPartsRequest
import dev.androidbroadcast.framesdk.models.DeviceAssetCreateDeprecated409Response
import dev.androidbroadcast.framesdk.models.DeviceAssetCreateDeprecatedRequest
import dev.androidbroadcast.framesdk.models.DeviceAssetCreateDeprecatedRequest1
import dev.androidbroadcast.framesdk.models.GetAssetTypeParameter
import dev.androidbroadcast.framesdk.models.HTTPError
import dev.androidbroadcast.framesdk.models.LibrarySearch

import dev.androidbroadcast.framesdk.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class AssetsApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Version an Asset
     * Add an asset to a version stack, or create one if one doesn&#39;t already exist
     * @param assetId 
     * @param addVersionToAssetRequest  (optional)
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun addVersionToAsset(assetId: kotlin.String, addVersionToAssetRequest: AddVersionToAssetRequest? = null): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = addVersionToAssetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets/{asset_id}/version".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Search for Assets
     * Search for Assets via query parameters
     * @param accountId  (optional)
     * @param filter Custom ES filters to apply to your query (optional)
     * @param include  (optional)
     * @param includeDeleted Flag to include soft-deleted records in results (optional)
     * @param opts Additional request options (optional)
     * @param page The page to retrieve (optional)
     * @param pageSize The number of results to include in the page (optional)
     * @param projectId  (optional)
     * @param properties  (optional)
     * @param q Search text (optional)
     * @param query Search text (optional)
     * @param sharedProjects  (optional)
     * @param sort Sorting parameters (optional)
     * @param teamId  (optional)
     * @param type  (optional)
     * @return kotlin.collections.List<Asset>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun assetSearchGet(accountId: kotlin.String? = null, filter: kotlin.String? = null, include: kotlin.String? = null, includeDeleted: kotlin.Boolean? = null, opts: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, projectId: kotlin.String? = null, properties: kotlin.String? = null, q: kotlin.String? = null, query: kotlin.String? = null, sharedProjects: kotlin.Boolean? = null, sort: kotlin.String? = null, teamId: AssetSearchGetTeamIdParameter? = null, type: kotlin.String? = null): HttpResponse<kotlin.collections.List<Asset>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        accountId?.apply { localVariableQuery["account_id"] = listOf("$accountId") }
        filter?.apply { localVariableQuery["filter"] = listOf("$filter") }
        include?.apply { localVariableQuery["include"] = listOf("$include") }
        includeDeleted?.apply { localVariableQuery["include_deleted"] = listOf("$includeDeleted") }
        opts?.apply { localVariableQuery["opts"] = listOf("$opts") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        projectId?.apply { localVariableQuery["project_id"] = listOf("$projectId") }
        properties?.apply { localVariableQuery["properties"] = listOf("$properties") }
        q?.apply { localVariableQuery["q"] = listOf("$q") }
        query?.apply { localVariableQuery["query"] = listOf("$query") }
        sharedProjects?.apply { localVariableQuery["shared_projects"] = listOf("$sharedProjects") }
        sort?.apply { localVariableQuery["sort"] = listOf("$sort") }
        teamId?.apply { localVariableQuery["team_id"] = listOf("$teamId") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/search/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<AssetSearchGetResponse>().map { value }
    }

    @Serializable(AssetSearchGetResponse.Companion::class)
    private class AssetSearchGetResponse(val value: List<Asset>) {
        companion object : KSerializer<AssetSearchGetResponse> {
            private val serializer: KSerializer<List<Asset>> = serializer<List<Asset>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: AssetSearchGetResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = AssetSearchGetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Search for Assets
     * Search for Assets using a JSON payload
     * @param assetSearch Asset search (optional)
     * @return kotlin.collections.List<Asset>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun assetSearchPost(assetSearch: AssetSearch? = null): HttpResponse<kotlin.collections.List<Asset>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = assetSearch

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/search/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<AssetSearchPostResponse>().map { value }
    }


    @Serializable(AssetSearchPostResponse.Companion::class)
    private class AssetSearchPostResponse(val value: List<Asset>) {
        companion object : KSerializer<AssetSearchPostResponse> {
            private val serializer: KSerializer<List<Asset>> = serializer<List<Asset>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: AssetSearchPostResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = AssetSearchPostResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Bulk copy assets
     * Copy a batch of asset ids to a new folder. You can also choose to copy over all or none of the comments from the original to the copied asset.
     * @param destinationId Destination folder &#x60;id&#x60; - must be in the same folder
     * @param batchCopyAssetRequest An array of batch operations (optional)
     * @return BatchCopyAsset200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchCopyAsset(destinationId: kotlin.String, batchCopyAssetRequest: BatchCopyAssetRequest? = null): HttpResponse<BatchCopyAsset200Response> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = batchCopyAssetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/batch/assets/{destination_id}/copy".replace("{" + "destination_id" + "}", "$destinationId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Bulk delete assets
     * Delete a list of Assets
     * @param batchDeleteAssetRequest Delete a list of Assets by their ID&#39;s (optional)
     * @return BatchCreateCollaborators200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchDeleteAsset(batchDeleteAssetRequest: BatchDeleteAssetRequest? = null): HttpResponse<BatchCreateCollaborators200Response> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = batchDeleteAssetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/batch/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Copy asset
     * Copy an Asset to a new location
     * @param destinationFolder Destination folder &#x60;id&#x60;
     * @param copyAssetRequest Asset copy request (optional)
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun copyAsset(destinationFolder: kotlin.String, copyAssetRequest: CopyAssetRequest? = null): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = copyAssetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets/{destination_folder}/copy".replace("{" + "destination_folder" + "}", "$destinationFolder"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create an Asset
     * Create a new asset.
     * @param assetId Asset ID
     * @param createAssetRequest While supported, we encourage you to switch from &#x60;application/x-ww-form-urlencoded&#x60; to &#x60;application/json&#x60; in order to support future workflows that will only be supported through JSON.  When &#x60;is_realtime_upload&#x60; is &#x60;true&#x60;, call must be made in &#x60;application/json&#x60;. (optional)
     * @return CreateAsset200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createAsset(assetId: kotlin.String, createAssetRequest: CreateAssetRequest? = null): HttpResponse<CreateAsset200Response> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = createAssetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets/{asset_id}/children".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Request upload URLs for real-time upload
     * Register real-time upload parts and generate presigned AWS S3 upload PUT URLs.
     * @param assetId Asset ID
     * @param createRealtimeUploadPartsRequest Enumerates parts that upload URLs should be created for. (optional)
     * @return CreateRealtimeUploadParts200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createRealtimeUploadParts(assetId: kotlin.String, createRealtimeUploadPartsRequest: CreateRealtimeUploadPartsRequest? = null): HttpResponse<CreateRealtimeUploadParts200Response> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = createRealtimeUploadPartsRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets/{asset_id}/realtime_upload/parts".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete an Asset
     * Delete the referenced Asset ID
     * @param assetId Asset ID
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deleteAsset(assetId: kotlin.String): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/assets/{asset_id}".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create C2C asset
     * Asset upload initiation specifically for C2C devices and applications.  Note: This endpoint used to be &#x60;/v2/assets&#x60;, and while that endpoint will continue to function as normal, we suggest you use this one instead.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param deviceAssetCreateDeprecatedRequest While supported, we encourage you to switch from &#x60;application/x-ww-form-urlencoded&#x60; to &#x60;application/json&#x60; in order to support future workflows that will only be supported through JSON.  When &#x60;is_realtime_upload&#x60; is &#x60;true&#x60;, call must be made in &#x60;application/json&#x60;. (optional)
     * @return CreateAsset200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceAssetCreate(xClientVersion: kotlin.String? = "0.0.0", deviceAssetCreateDeprecatedRequest: DeviceAssetCreateDeprecatedRequest? = null): HttpResponse<CreateAsset200Response> {

        val localVariableAuthNames = listOf<String>("C2COAuth2", "C2CDeviceAuth")

        val localVariableBody = deviceAssetCreateDeprecatedRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/devices/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create C2C asset
     * **THIS ENDPOINT IS DEPRECATED**. Please use &#x60;/v2/devices/assets&#x60; instead. While this endpoint will continue to function as normal, we ask that integrations begin using the new endpoint instead for consistency with the rest of the C2C API.  Asset upload initiation specifically for C2C devices and applications.
     * @param xClientVersion Firmware or software version of a C2C integration. Will be used to determine the correct Device Model configuration for the device when multiple are available. Must be a valid semantic version.    For more on semantic versions, see here: https://semver.org/ (optional, default to "0.0.0")
     * @param deviceAssetCreateDeprecatedRequest While supported, we encourage you to switch from &#x60;application/x-ww-form-urlencoded&#x60; to &#x60;application/json&#x60; in order to support future workflows that will only be supported through JSON.  When &#x60;is_realtime_upload&#x60; is &#x60;true&#x60;, call must be made in &#x60;application/json&#x60;. (optional)
     * @return CreateAsset200Response
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deviceAssetCreateDeprecated(xClientVersion: kotlin.String? = "0.0.0", deviceAssetCreateDeprecatedRequest: DeviceAssetCreateDeprecatedRequest? = null): HttpResponse<CreateAsset200Response> {

        val localVariableAuthNames = listOf<String>("C2COAuth2", "C2CDeviceAuth")

        val localVariableBody = deviceAssetCreateDeprecatedRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        xClientVersion?.apply { localVariableHeaders["x-client-version"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get an Asset
     * Fetch the full Asset manifest
     * @param assetId Asset ID
     * @param includeDeleted  (optional)
     * @param type  (optional)
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getAsset(assetId: kotlin.String, includeDeleted: kotlin.Boolean? = null, type: GetAssetTypeParameter? = null): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeDeleted?.apply { localVariableQuery["include_deleted"] = listOf("$includeDeleted") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/assets/{asset_id}".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter include
     */
    @Serializable
    enum class IncludeGetAssets(val value: kotlin.String) {
        
        @SerialName(value = "children")
        children("children"),
        
        @SerialName(value = "cover_asset")
        cover_asset("cover_asset"),
        
        @SerialName(value = "review_links")
        review_links("review_links")
        
    }


    /**
     * enum for parameter sort
     */
    @Serializable
    enum class SortGetAssets(val value: kotlin.String) {
        
        @SerialName(value = "comment_count")
        comment_count("comment_count"),
        
        @SerialName(value = "filesize")
        filesize("filesize"),
        
        @SerialName(value = "filetype")
        filetype("filetype"),
        
        @SerialName(value = "id")
        id("id"),
        
        @SerialName(value = "label")
        label("label"),
        
        @SerialName(value = "name")
        name("name"),
        
        @SerialName(value = "uploaded_at")
        uploaded_at("uploaded_at")
        
    }

    /**
     * Fetch child Assets
     * Get child elements of a given asset. Can be used to get the items in a review link, version stack, folder, as well as including an asset to use on the cover of a folder.
     * @param assetId Asset ID
     * @param includeDeleted Include deleted files by passing &#x60;true&#x60; (optional, default to false)
     * @param include Include additional \&quot;pre-loads\&quot; for related resources (optional)
     * @param sort The sorting order for the returned list of Assets. Supporting chaining like &#x60;comment_count,id&#x60;. Also supports reversing the order with &#x60;-&#x60; i.e. &#x60;-comment_count,id&#x60; or &#x60;filetype,-id&#x60;. (optional)
     * @param page The current page number in this Paginated Response (optional)
     * @param pageSize Number of pages in this Paginated Response (optional)
     * @return kotlin.collections.List<Asset>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getAssets(assetId: kotlin.String, includeDeleted: kotlin.Boolean? = false, include: IncludeGetAssets? = null, sort: SortGetAssets? = null, page: kotlin.Double? = null, pageSize: kotlin.Double? = null): HttpResponse<kotlin.collections.List<Asset>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeDeleted?.apply { localVariableQuery["include_deleted"] = listOf("$includeDeleted") }
        include?.apply { localVariableQuery["include"] = listOf("${ include.value }") }
        sort?.apply { localVariableQuery["sort"] = listOf("${ sort.value }") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/assets/{asset_id}/children".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetAssetsResponse>().map { value }
    }

    @Serializable(GetAssetsResponse.Companion::class)
    private class GetAssetsResponse(val value: List<Asset>) {
        companion object : KSerializer<GetAssetsResponse> {
            private val serializer: KSerializer<List<Asset>> = serializer<List<Asset>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: GetAssetsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = GetAssetsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get audio for an Asset
     * Fetch the audio tracks for a given Asset
     * @param assetId 
     * @return AssetAudio
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getAudio(assetId: kotlin.String): HttpResponse<AssetAudio> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/assets/{asset_id}/audio".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get the subtitles for an Asset
     * Fetch subtitles that have been hoisted out by the media pipeline
     * @param assetId 
     * @return AssetSubtitle
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSubtitles(assetId: kotlin.String): HttpResponse<AssetSubtitle> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/assets/{asset_id}/subtitles".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Advanced search for Assets
     * Advanced Asset Search
     * @param accountId  (optional)
     * @param filter Custom ES filters to apply to your query (optional)
     * @param includeDeleted Flag to include soft-deleted records in results (optional)
     * @param opts Additional request options (optional)
     * @param page The page to retrieve (optional)
     * @param pageSize The number of results to include in the page (optional)
     * @param q Search text (optional)
     * @param query Search text (optional)
     * @param sort Sorting parameters (optional)
     * @return kotlin.collections.List<Asset>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun librarySearchGet(accountId: kotlin.String? = null, filter: kotlin.String? = null, includeDeleted: kotlin.Boolean? = null, opts: kotlin.String? = null, page: kotlin.Int? = null, pageSize: kotlin.Int? = null, q: kotlin.String? = null, query: kotlin.String? = null, sort: kotlin.String? = null): HttpResponse<kotlin.collections.List<Asset>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        accountId?.apply { localVariableQuery["account_id"] = listOf("$accountId") }
        filter?.apply { localVariableQuery["filter"] = listOf("$filter") }
        includeDeleted?.apply { localVariableQuery["include_deleted"] = listOf("$includeDeleted") }
        opts?.apply { localVariableQuery["opts"] = listOf("$opts") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        q?.apply { localVariableQuery["q"] = listOf("$q") }
        query?.apply { localVariableQuery["query"] = listOf("$query") }
        sort?.apply { localVariableQuery["sort"] = listOf("$sort") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v2/search/library",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<LibrarySearchGetResponse>().map { value }
    }

    @Serializable(LibrarySearchGetResponse.Companion::class)
    private class LibrarySearchGetResponse(val value: List<Asset>) {
        companion object : KSerializer<LibrarySearchGetResponse> {
            private val serializer: KSerializer<List<Asset>> = serializer<List<Asset>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: LibrarySearchGetResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = LibrarySearchGetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Advanced search for Assets
     * Search using ElasticSearch key/value pairs
     * @param librarySearch Advanced asset search (optional)
     * @return kotlin.collections.List<Asset>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun librarySearchPost(librarySearch: LibrarySearch? = null): HttpResponse<kotlin.collections.List<Asset>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = librarySearch

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/search/library",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<LibrarySearchPostResponse>().map { value }
    }


    @Serializable(LibrarySearchPostResponse.Companion::class)
    private class LibrarySearchPostResponse(val value: List<Asset>) {
        companion object : KSerializer<LibrarySearchPostResponse> {
            private val serializer: KSerializer<List<Asset>> = serializer<List<Asset>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: LibrarySearchPostResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = LibrarySearchPostResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Move asset
     * Move an asset to a new location
     * @param destinationFolder Destination folder &#x60;id&#x60;
     * @param copyAssetRequest Asset copy request (optional)
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun moveAsset(destinationFolder: kotlin.String, copyAssetRequest: CopyAssetRequest? = null): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = copyAssetRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v2/assets/{destination_folder}/move".replace("{" + "destination_folder" + "}", "$destinationFolder"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Unversion an Asset
     * Unversion an Asset from a Version Stack
     * @param assetId 
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun unversionAsset(assetId: kotlin.String): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v2/assets/{asset_id}/unversion".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update an Asset
     * Update the manifest on an Asset
     * @param assetId Asset ID
     * @return Asset
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateAsset(assetId: kotlin.String): HttpResponse<Asset> {

        val localVariableAuthNames = listOf<String>("OAuth2", "OAuth2", "JWT", "DeveloperToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v2/assets/{asset_id}".replace("{" + "asset_id" + "}", "$assetId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
